/*-
 * Copyright (c) 2008-2012 WiredTiger, Inc.
 *	All rights reserved.
 *
 * See the file LICENSE for redistribution information.
 */

#include "wt_internal.h"

/*
 * __wt_config_check--
 *	Check that all keys in an application-supplied config string match
 *	what is specified in the check string.
 *
 * All check strings are generated by dist/config.py from the constraints given
 * in dist/api_data.py
 */
int
__wt_config_check(WT_SESSION_IMPL *session,
    const char *checks, const char *config)
{
	WT_CONFIG parser, cparser, sparser;
	WT_CONFIG_ITEM k, v, chk, ck, cv, dummy;
	int found, ret;

	/* It is always okay to pass NULL. */
	if (config == NULL)
		return (0);

	WT_RET(__wt_config_init(session, &parser, config));
	while ((ret = __wt_config_next(&parser, &k, &v)) == 0) {
		if (k.type != ITEM_STRING && k.type != ITEM_ID)
			WT_RET_MSG(session, EINVAL,
			    "Invalid configuration key found: '%.*s'",
			    (int)k.len, k.str);

		if ((ret = __wt_config_getone(session,
		    checks, &k, &chk)) != 0) {
			if (ret == WT_NOTFOUND)
				WT_RET_MSG(session, EINVAL,
				    "Unknown configuration key found: '%.*s'",
				    (int)k.len, k.str);
			return (ret);
		}

		WT_RET(__wt_config_subinit(session, &cparser, &chk));
		while ((ret = __wt_config_next(&cparser, &ck, &cv)) == 0) {
			if (strncmp(ck.str, "type", ck.len) == 0) {
				if ((strncmp(cv.str, "int", cv.len) == 0 &&
				    v.type != ITEM_NUM) ||
				    (strncmp(cv.str, "boolean", cv.len) == 0 &&
				    (v.type != ITEM_NUM ||
				    (v.val != 0 && v.val != 1))) ||
				    (strncmp(cv.str, "list", cv.len) == 0 &&
				    v.len > 0 && v.type != ITEM_STRUCT))
					WT_RET_MSG(session, EINVAL,
					    "Invalid value type "
					    "for key '%.*s': expected a %.*s",
					    (int)k.len, k.str,
					    (int)cv.len, cv.str);
			} else if (strncmp(ck.str, "min", ck.len) == 0) {
				if (v.val < cv.val)
					WT_RET_MSG(session, EINVAL,
					    "Value too small for key '%.*s' "
					    "the minimum is %.*s",
					    (int)k.len, k.str,
					    (int)cv.len, cv.str);
			} else if (strncmp(ck.str, "max", ck.len) == 0) {
				if (v.val > cv.val)
					WT_RET_MSG(session, EINVAL,
					    "Value too large for key '%.*s' "
					    "the maximum is %.*s",
					    (int)k.len, k.str,
					    (int)cv.len, cv.str);
			} else if (strncmp(ck.str, "choices", ck.len) == 0) {
				if (v.len == 0)
					WT_RET_MSG(session, EINVAL,
					    "Key '%.*s' requires a value",
					    (int)k.len, k.str);
				if (v.type == ITEM_STRUCT) {
					/*
					 * Handle the 'verbose' case of a list
					 * containing restricted choices.
					 */
					WT_RET(__wt_config_subinit(session,
					    &sparser, &v));
					found = 1;
					while (found &&
					    (ret = __wt_config_next(&sparser,
					    &v, &dummy)) == 0) {
						ret = __wt_config_subgetraw(
						    session, &cv, &v, &dummy);
						found = (ret == 0);
					}
				} else  {
					ret = __wt_config_subgetraw(session,
					    &cv, &v, &dummy);
					found = (ret == 0);
				}

				if (ret != 0 && ret != WT_NOTFOUND)
					return (ret);
				if (!found)
					WT_RET_MSG(session, EINVAL,
					    "Value '%.*s' not a "
					    "permitted choice for key '%.*s'",
					    (int)v.len, v.str,
					    (int)k.len, k.str);
			} else
				WT_RET_MSG(session, EINVAL,
				    "unexpected configuration description "
				    "keyword %.*s", (int)ck.len, ck.str);
		}
	}

	if (ret == WT_NOTFOUND)
		ret = 0;

	return (ret);
}
