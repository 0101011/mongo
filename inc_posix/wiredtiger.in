/*-
 * See the file LICENSE for redistribution information.
 *
 * Copyright (c) 2008 WiredTiger Software.  All rights reserved.
 *
 * $Id$
 */

#ifndef	__WIREDTIGER_H_
#define	__WIREDTIGER_H_

#if defined(__cplusplus)
extern "C" {
#endif

/*******************************************
 * Version information
 *******************************************/
#define	WIREDTIGER_VERSION_MAJOR	@WIREDTIGER_VERSION_MAJOR@
#define	WIREDTIGER_VERSION_MINOR	@WIREDTIGER_VERSION_MINOR@
#define	WIREDTIGER_VERSION_PATCH	@WIREDTIGER_VERSION_PATCH@
#define	WIREDTIGER_VERSION_STRING	@WIREDTIGER_VERSION_STRING@

/*******************************************
 * Required includes
 *******************************************/
@wiredtiger_includes_decl@

/*******************************************
 * Portable type names
 *******************************************/
@int8_decl@
@u_int8_decl@
@int16_decl@
@u_int16_decl@
@int32_decl@
@u_int32_decl@
@int64_decl@
@u_int64_decl@

@u_char_decl@
@u_short_decl@
@u_int_decl@
@u_long_decl@
@u_quad_decl@

@uintmax_t_decl@
@uintptr_t_decl@

/*******************************************
 * Forward declarations
 *******************************************/
struct __db;			typedef struct __db DB;
struct __dbc;			typedef struct __dbc DBC;
struct __dbt;			typedef struct __dbt DBT;
struct __env;			typedef struct __env ENV;
struct __idb;			typedef struct __idb IDB;
struct __idbc;			typedef struct __idbc IDBC;
struct __ienv;			typedef struct __ienv IENV;
struct __wt_cache;		typedef struct __wt_cache WT_CACHE;
struct __wt_mtx;		typedef struct __wt_mtx WT_MTX;
struct __wt_stats;		typedef struct __wt_stats WT_STATS;
struct __wt_toc;		typedef struct __wt_toc WT_TOC;

/*******************************************
 * Exported types
 *******************************************/
typedef u_int64_t wt_recno_t;		/* logical record numbers */

/*******************************************
 * Key/data structure -- a Data-Base Thang
 *******************************************/
struct __dbt {
	void	 *data;			/* returned/specified data */
	u_int32_t size;			/* returned/specified data length */

	u_int32_t data_len;		/* associated memory size */

					/* callback return */
	int (*callback)(DB *, DBT *, DBT *);

	u_int32_t flags;
};

/*******************************************
 * Application thread-of-control information
 *******************************************/
struct __wt_toc {
	WT_MTX  *block;			/* Thread's blocking mutex */

	/*
	 * Each thread-of-control has a reserved slot in each server's WT_TOC
	 * array, which is how a thread-of-control schedules itself.   The
	 * value is assigned when the WT_TOC is created.  Since these values
	 * are unique across all WT_TOCs, it can also be used as an ID field.
	 */
	u_int	srvr_slot;

	/*
	 * Enclosing environment, set when the WT_TOC is created (which
	 * implies that threads-of-control are confined to an environment).
	 */
	ENV	*env;			/* Operation environment */

	/*
	 * Payload: when a WT_TOC crosses the API layer, it gets loaded with
	 * the following information used by underlying functions to figure
	 * out what to do.
	 */
	DB	*db;			/* Operation database */
	int	 op;			/* Operation code */
	void	*argp;			/* Operation parameters */
	int      ret;			/* Operation return status */

	/*
	 * Cache of database pages.   Normally, each server "owns" its cache
	 * pages, and no locking is required since the server is the only
	 * thread of control to access those pages.   An exception is the
	 * primary server: (1) if the application is single-threaded, the
	 * primary WT_TOC owns all the pages, (2) if the application has
	 * multiple server threads, the primary WT_TOC owns the pinned pages
	 * that are accessed by per-database server threads, without locking
	 * and without coordination.   To handle these two architectures, we
	 * don't put pages in the primary WT_TOC, instead, we maintain the
	 * pages in the IDB structure.   That solves the problem in (1) where
	 * we can't tell the pages in different databases apart (there's just
	 * an addr/offset pair in the WT_PAGE, no file ID), and the problem
	 * in (2) where multiple threads of control are walking the list of
	 * pages because we only read those pages when the database is first
	 * opened.
	 *
	 * When a thread-of-control is scheduled for an operation, the cache
	 * pointer is set to reference the "true" cache.  Note that in some
	 * operations (ENV operations, for example), there may be no cache
	 * at all.
	 */
#define	WT_TOC_SET_CACHE(toc, srvr) do {				\
	if ((srvr) != NULL && (srvr)->cache != NULL)			\
		(toc)->cache = (srvr)->cache;				\
	else if ((toc)->db != NULL)					\
		(toc)->cache = (toc)->db->idb->cache;			\
	else								\
		(toc)->cache = NULL;					\
	} while (0)

	WT_CACHE *cache;

	/*
	 * Threads-of-control run (1) without any server, (2) in the primary
	 * server, or (3) in a secondary server.   In cases 1 and 2, the op
	 * may be rescheduled for a secondary server, in which case the server
	 * ID and a Btree root page and isleaf information is set.   When we
	 * are returning control to the application, clear any information we
	 * have set so future calls don't get re-directed to the wrong server.
	 */
#define	WT_TOC_CLEAR_SRVR(toc) do {					\
	(toc)->srvr = WT_SRVR_PRIMARY;					\
	(toc)->root_addr = WT_ADDR_INVALID;				\
	} while (0)

	int	  srvr;			/* Requested server */
	u_int32_t root_addr;		/* Server's root page */
	u_int64_t root_record_cnt;	/* Server's record count */
	int	  root_isleaf;		/* Server's root page type */

	DBT	  key, data;		/* Returned key/data pairs */

	 u_int32_t flags;

	/*
	 * DO NOT EDIT: automatically built by dist/api.py.
	 * WT_TOC handle api section: BEGIN
	 */
	int (*destroy)(
	    WT_TOC *, u_int32_t );
	/*
	 * WT_TOC handle api section: END
	 * DO NOT EDIT: automatically built by dist/api.py.
	 */
};

/*******************************************
 * Database handle
 *******************************************/
struct __db {
	ENV	*env;			/* Enclosing environment */
	IENV	*ienv;			/* Private environment object */
	IDB	*idb;			/* Private object */

	void	*app_private;		/* Application-private information */

	u_int32_t flags;

	/*
	 * DO NOT EDIT: automatically built by dist/api.py.
	 * Db handle api section: BEGIN
	 */
	int (*bulk_load)(
	    DB *, WT_TOC *, u_int32_t , int (*)(DB *, DBT **, DBT **));

	int (*close)(
	    DB *, WT_TOC *, u_int32_t );

	int (*destroy)(
	    DB *, WT_TOC *, u_int32_t );

	int (*dump)(
	    DB *, WT_TOC *, FILE *, u_int32_t );

	void (*err)(
	    DB *, int , const char *, ...);

	void (*errx)(
	    DB *, const char *, ...);

	int (*get)(
	    DB *, WT_TOC *, DBT *, DBT *, DBT *, u_int32_t );

	int (*get_btree_compare)(
	    DB *, WT_TOC *, int (**)(DB *, const DBT *, const DBT *));

	int (*get_btree_compare_int)(
	    DB *, WT_TOC *, int *);

	int (*get_btree_dup_compare)(
	    DB *, WT_TOC *, int (**)(DB *, const DBT *, const DBT *));

	int (*get_btree_dup_offpage)(
	    DB *, WT_TOC *, u_int32_t *);

	int (*get_btree_itemsize)(
	    DB *, WT_TOC *, u_int32_t *, u_int32_t *);

	int (*get_btree_pagesize)(
	    DB *, WT_TOC *, u_int32_t *, u_int32_t *, u_int32_t *, u_int32_t *);

	int (*get_errcall)(
	    DB *, WT_TOC *, void (**)(const DB *, const char *));

	int (*get_errfile)(
	    DB *, WT_TOC *, FILE **);

	int (*get_errpfx)(
	    DB *, WT_TOC *, const char **);

	int (*get_recno)(
	    DB *, WT_TOC *, u_int64_t , DBT *, DBT *, DBT *, u_int32_t );

	int (*get_recno_stoc)(
	    DB *, WT_TOC *, u_int64_t , DBT *, DBT *, DBT *, u_int32_t );

	int (*get_stoc)(
	    DB *, WT_TOC *, DBT *, DBT *, DBT *, u_int32_t );

	int (*open)(
	    DB *, WT_TOC *, const char *, mode_t , u_int32_t );

	int (*btree_compare)(DB *, const DBT *, const DBT *);
	int (*set_btree_compare)(
	    DB *, WT_TOC *, int (*)(DB *, const DBT *, const DBT *));

	int btree_compare_int;
	int (*set_btree_compare_int)(
	    DB *, WT_TOC *, int );

	int (*btree_dup_compare)(DB *, const DBT *, const DBT *);
	int (*set_btree_dup_compare)(
	    DB *, WT_TOC *, int (*)(DB *, const DBT *, const DBT *));

	u_int32_t btree_dup_offpage;
	int (*set_btree_dup_offpage)(
	    DB *, WT_TOC *, u_int32_t );

	u_int32_t intlitemsize;
	u_int32_t leafitemsize;
	int (*set_btree_itemsize)(
	    DB *, WT_TOC *, u_int32_t , u_int32_t );

	u_int32_t allocsize;
	u_int32_t intlsize;
	u_int32_t leafsize;
	u_int32_t extsize;
	int (*set_btree_pagesize)(
	    DB *, WT_TOC *, u_int32_t , u_int32_t , u_int32_t , u_int32_t );

	void (*errcall)(const DB *, const char *);
	int (*set_errcall)(
	    DB *, WT_TOC *, void (*)(const DB *, const char *));

	FILE *errfile;
	int (*set_errfile)(
	    DB *, WT_TOC *, FILE *);

	const char *errpfx;
	int (*set_errpfx)(
	    DB *, WT_TOC *, const char *);

	int (*stat_clear)(
	    DB *, WT_TOC *, u_int32_t );

	int (*stat_print)(
	    DB *, WT_TOC *, FILE * , u_int32_t );

	int (*sync)(
	    DB *, WT_TOC *, u_int32_t );

	int (*verify)(
	    DB *, WT_TOC *, u_int32_t );
	/*
	 * Db handle api section: END
	 * DO NOT EDIT: automatically built by dist/api.py.
	 */
};

/*******************************************
 * Cursor handle
 *******************************************/
struct __dbc {
	IDBC *idbc;			/* Private object */

	u_int32_t flags;
};

/*******************************************
 * Database environment handle
 *******************************************/
struct __env {
	IENV	*ienv;			/* Private object */

	void	*app_private;		/* Application-private information */

	u_int32_t flags;

	/*
	 * DO NOT EDIT: automatically built by dist/api.py.
	 * Env handle api section: BEGIN
	 */
	int (*close)(
	    ENV *, WT_TOC *, u_int32_t );

	int (*db_create)(
	    ENV *, WT_TOC *, u_int32_t , DB **);

	int (*destroy)(
	    ENV *, u_int32_t );

	void (*err)(
	    ENV *, int , const char *, ...);

	void (*errx)(
	    ENV *, const char *, ...);

	int (*get_cachesize)(
	    ENV *, WT_TOC *, u_int32_t *);

	int (*get_errcall)(
	    ENV *, WT_TOC *, void (**)(const ENV *, const char *));

	int (*get_errfile)(
	    ENV *, WT_TOC *, FILE **);

	int (*get_errpfx)(
	    ENV *, WT_TOC *, const char **);

	int (*get_verbose)(
	    ENV *, WT_TOC *, u_int32_t *);

	int (*open)(
	    ENV *, WT_TOC *, const char *, mode_t , u_int32_t );

	u_int32_t cachesize;
	int (*set_cachesize)(
	    ENV *, WT_TOC *, u_int32_t );

	void (*errcall)(const ENV *, const char *);
	int (*set_errcall)(
	    ENV *, WT_TOC *, void (*)(const ENV *, const char *));

	FILE *errfile;
	int (*set_errfile)(
	    ENV *, WT_TOC *, FILE *);

	const char *errpfx;
	int (*set_errpfx)(
	    ENV *, WT_TOC *, const char *);

	u_int32_t verbose;
	int (*set_verbose)(
	    ENV *, WT_TOC *, u_int32_t );

	int (*start)(
	    ENV *, u_int32_t );

	int (*stat_clear)(
	    ENV *, WT_TOC *, u_int32_t );

	int (*stat_print)(
	    ENV *, WT_TOC *, FILE *, u_int32_t );

	int (*stop)(
	    ENV *, u_int32_t );

	int (*toc_create)(
	    ENV *, u_int32_t , WT_TOC **);
	/*
	 * Env handle api section: END
	 * DO NOT EDIT: automatically built by dist/api.py.
	 */
};

/*******************************************
 * Prototypes.
 *******************************************/
int	 wt_env_create(u_int32_t, ENV **);
char	*wt_strerror(int);
char	*wt_version(int *, int *, int *);

/*******************************************
 * API flags
 *******************************************/
/*
 * DO NOT EDIT: automatically built by dist/api.py.
 * API flags section: BEGIN
 */
#define	WT_ALLOCATED					0x00000001
#define	WT_CREATE					0x00000001
#define	WT_DBT_ALLOC					0x00000001
#define	WT_DEBUG					0x00000002
#define	WT_DUPLICATES					0x00000002
#define	WT_MODIFIED					0x00000002
#define	WT_PRINTABLES					0x00000001
#define	WT_READONLY					0x00000001
#define	WT_RESCHEDULE					0x00000001
#define	WT_RUNNING					0x00000002
#define	WT_SINGLE_THREADED				0x00000001
#define	WT_SORTED_INPUT					0x00000001
#define	WT_UNFORMATTED					0x00000001
#define	WT_VERB_FILEOPS					0x00000004
#define	WT_VERB_FILEOPS_ALL				0x00000002
#define	WT_VERB_SERVERS					0x00000001

#define	WT_APIMASK_DB					0x00000000
#define	WT_APIMASK_DB_BULK_LOAD				0x00000003
#define	WT_APIMASK_DB_CLOSE				0x00000000
#define	WT_APIMASK_DB_DESTROY				0x00000000
#define	WT_APIMASK_DB_DUMP				0x00000003
#define	WT_APIMASK_DB_GET				0x00000000
#define	WT_APIMASK_DB_GET_RECNO				0x00000000
#define	WT_APIMASK_DB_OPEN				0x00000001
#define	WT_APIMASK_DB_STAT_CLEAR			0x00000000
#define	WT_APIMASK_DB_STAT_PRINT			0x00000000
#define	WT_APIMASK_DB_SYNC				0x00000000
#define	WT_APIMASK_DB_VERIFY				0x00000000
#define	WT_APIMASK_DBT					0x00000001
#define	WT_APIMASK_ENV					0x00000000
#define	WT_APIMASK_ENV_CLOSE				0x00000000
#define	WT_APIMASK_ENV_DB_CREATE			0x00000000
#define	WT_APIMASK_ENV_DESTROY				0x00000000
#define	WT_APIMASK_ENV_OPEN				0x00000000
#define	WT_APIMASK_ENV_START				0x00000001
#define	WT_APIMASK_ENV_STAT_CLEAR			0x00000000
#define	WT_APIMASK_ENV_STAT_PRINT			0x00000000
#define	WT_APIMASK_ENV_STOP				0x00000000
#define	WT_APIMASK_ENV_TOC_CREATE			0x00000000
#define	WT_APIMASK_ENV_VERBOSE				0x00000007
#define	WT_APIMASK_IDB					0x00000001
#define	WT_APIMASK_IENV					0x00000001
#define	WT_APIMASK_TOC					0x00000003
#define	WT_APIMASK_TOC_DESTROY				0x00000000
#define	WT_APIMASK_WT_CACHE				0x00000001
#define	WT_APIMASK_WT_CACHE_IN				0x00000001
#define	WT_APIMASK_WT_CACHE_OUT				0x00000003
#define	WT_APIMASK_WT_DB_CREATE				0x00000000
#define	WT_APIMASK_WT_ENV_CREATE			0x00000000
#define	WT_APIMASK_WT_INDX				0x00000001
#define	WT_APIMASK_WT_OPEN				0x00000001
#define	WT_APIMASK_WT_PAGE				0x00000003
#define	WT_APIMASK_WT_RETURN				0x00000001
/*
 * API flags section: END
 * DO NOT EDIT: automatically built by dist/api.py.
 */

/*******************************************
 * Error returns
 *******************************************/
/*
 * DO NOT EDIT: automatically built by dist/api_err.py.
 * Error return section: BEGIN
 */
#define	WT_ERROR	-31800
#define	WT_NOTFOUND	-31801
#define	WT_TOOSMALL	-31802
/*
 * Error return section: END
 * DO NOT EDIT: automatically built by dist/api_err.py.
 */

#if defined(__cplusplus)
}
#endif
#endif /* __WIREDTIGER_H_ */
