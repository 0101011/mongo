/*-
 * See the file LICENSE for redistribution information.
 *
 * Copyright (c) 2008-2011 WiredTiger, Inc.
 *	All rights reserved.
 */

#ifndef	__WIREDTIGER_H_
#define	__WIREDTIGER_H_

#if defined(__cplusplus)
extern "C" {
#endif

/*******************************************
 * Version information
 *******************************************/
#define	WIREDTIGER_VERSION_MAJOR	@VERSION_MAJOR@
#define	WIREDTIGER_VERSION_MINOR	@VERSION_MINOR@
#define	WIREDTIGER_VERSION_PATCH	@VERSION_PATCH@
#define	WIREDTIGER_VERSION_STRING	@VERSION_STRING@

/*******************************************
 * Required includes
 *******************************************/
@wiredtiger_includes_decl@

/*******************************************
 * Portable type names
 *******************************************/
@int8_decl@
@u_int8_decl@
@int16_decl@
@u_int16_decl@
@int32_decl@
@u_int32_decl@
@int64_decl@
@u_int64_decl@

@u_char_decl@
@u_short_decl@
@u_int_decl@
@u_long_decl@
@u_quad_decl@

@uintmax_t_decl@
@uintptr_t_decl@

#if defined(DOXYGEN) || defined(SWIG)
#define	__F(func) func
#else
#define	__F(func) (*func)
#endif

#ifdef SWIG
%{
#include <wiredtiger.h>
%}
#endif

/*! @defgroup wt WiredTiger API
 * The commonly-used functions, handles and methods that applications use to
 * access and manage data with WiredTiger.
 *
 * @{
 */

/*******************************************
 * Public forward structure declarations
 *******************************************/
struct wt_collator;	    typedef struct wt_collator WT_COLLATOR;
struct wt_compressor;	    typedef struct wt_compressor WT_COMPRESSOR;
struct wt_connection;	    typedef struct wt_connection WT_CONNECTION;
struct wt_cursor;	    typedef struct wt_cursor WT_CURSOR;
struct wt_cursor_type;	    typedef struct wt_cursor_type WT_CURSOR_TYPE;
struct wt_event_handler;    typedef struct wt_event_handler WT_EVENT_HANDLER;
struct wt_extension_api;    typedef struct wt_extension_api WT_EXTENSION_API;
struct wt_extractor;	    typedef struct wt_extractor WT_EXTRACTOR;
struct wt_item;		    typedef struct wt_item WT_ITEM;
struct wt_session;	    typedef struct wt_session WT_SESSION;

/*!
 * A raw item of data to be managed.  Data items have a pointer to the data and
 * a length (limited to 4GB for items stored in tables).  Records consist of a
 * pair of items: a key and an associated value.
 */
struct wt_item {
	/*!
	 * The memory reference of the data item.
	 *
	 * For items returned by a WT_CURSOR, the pointer is only valid until
	 * the next operation on that cursor.  Applications that need to keep
	 * an item across multiple cursor operations must make a copy.
	 */
	const void *data;

	/*!
	 * The number of bytes in the data item.
	 */
	uint32_t size;
};

#ifndef DOXYGEN
/* Forward structure declarations */
struct wt_buf;		    typedef struct wt_buf WT_BUF;

/*!
 * A data item with memory management.  Used internally to manage returned keys
 * and values in the WT_CURSOR implementation.
 */
struct wt_buf {
	/*
	 * Note: the first two fields must match WT_ITEM, we cast between
	 * those types.
	 */
	/*! The memory reference of the data item. */
	const void *data;
	/*! The number of bytes in the data item. */
	uint32_t size;

	/* This appears in the middle of the struct to avoid padding. */
#define	WT_BUF_INUSE					0x00000001
	/*! Object flags (internal use). */
	uint32_t flags;

	/*! Managed memory chunk (internal use). */
	void *mem;
	/*! Managed memory size (internal use). */
	size_t memsize;
};
#endif

/*!
 * A WT_CURSOR handle is the interface to a cursor.
 *
 * Cursors allow data to be searched, stepped through and updated: the
 * so-called CRUD operations (create, read, update and delete).
 *
 * Raw data is represented by key/value pairs of WT_ITEM structures, but
 * cursors can also provide access to fields within the key and value if the
 * formats are described in the WT_SESSION::create method.
 *
 * A cursor can be positioned in a collection of data.  Cursors are opened in
 * the context of a session (which may have an associated transaction), and can
 * query and update records.  In the common case, a cursor is used to access
 * records in a table.  However, cursors can be used on subsets of tables (such
 * as a single column or a projection of multiple columns), as an interface to
 * statistics, configuration data or application-specific data sources.  See
 * WT_SESSION::open_cursor for more information.
 *
 * <b>Thread safety:</b> A WT_CURSOR handle cannot be shared between threads:
 * it may only be used within the same thread as the encapsulating WT_SESSION.
 */
struct wt_cursor {
	WT_SESSION *session;	/*!< The session handle for this cursor. */

	/*!
	 * The format of the data packed into key items.  See @ref packing for
	 * details.  If not set, a default value of "u" is assumed, and
	 * applications must use WT_ITEM structures to manipulate untyped byte
	 * arrays.
	 */
	const char *key_format;

	/*!
	 * The format of the data packed into value items.  See @ref packing
	 * for details.  If not set, a default value of "u" is assumed, and
	 * applications must use WT_ITEM structures to manipulate untyped byte
	 * arrays.
	 */
	const char *value_format;

	/*! @name Data access
	 * @{
	 */
	/*! Get the key for the current record.
	 *
	 * @snippet ex_all.c Get the cursor's string key
	 *
	 * @snippet ex_all.c Get the cursor's record number key
	 *
	 * @param cursor the cursor handle
	 * @errors
	 */
	int __F(get_key)(WT_CURSOR *cursor, ...);

	/*! Get the value for the current record.
	 *
	 * @snippet ex_all.c Get the cursor's string value
	 *
	 * @snippet ex_all.c Get the cursor's raw value
	 *
	 * @param cursor the cursor handle
	 * @errors
	 */
	int __F(get_value)(WT_CURSOR *cursor, ...);

	/*! Set the key for the next operation.
	 *
	 * @snippet ex_all.c Set the cursor's string key
	 *
	 * @snippet ex_all.c Set the cursor's record number key
	 *
	 * @param cursor the cursor handle
	 *
	 * If an error occurs during this operation, a flag will be set in the
	 * cursor, and the next operation to access the key will fail.  This
	 * simplifies error handling in applications.
	 */
	void __F(set_key)(WT_CURSOR *cursor, ...);

	/*! Set the value for the next operation.
	 *
	 * @snippet ex_all.c Set the cursor's string value
	 *
	 * @snippet ex_all.c Set the cursor's raw value
	 *
	 * @param cursor the cursor handle
	 *
	 * If an error occurs during this operation, a flag will be set in the
	 * cursor, and the next operation to access the value will fail.  This
	 * simplifies error handling in applications.
	 */
	void __F(set_value)(WT_CURSOR *cursor, ...);
	/*! @} */

	/*! @name Cursor positioning
	 * @{
	 */
	/*! Return the first record.
	 *
	 * @snippet ex_all.c Return the first key/value pair
	 *
	 * @param cursor the cursor handle
	 * @errors
	 */
	int __F(first)(WT_CURSOR *cursor);

	/*! Return the last record.
	 *
	 * @snippet ex_all.c Return the last key/value pair
	 *
	 * @param cursor the cursor handle
	 * @errors
	 */
	int __F(last)(WT_CURSOR *cursor);

	/*! Return the next record.
	 *
	 * @snippet ex_all.c Return the next key/value pair
	 *
	 * @param cursor the cursor handle
	 * @errors
	 */
	int __F(next)(WT_CURSOR *cursor);

	/*! Return the previous record.
	 *
	 * @snippet ex_all.c Return the previous key/value pair
	 *
	 * @param cursor the cursor handle
	 * @errors
	 */
	int __F(prev)(WT_CURSOR *cursor);

	/*! Return the record matching the key; the key must first be set.
	 *
	 * @snippet ex_all.c Search for an exact match
	 *
	 * @param cursor the cursor handle
	 * @errors
	 */
	int __F(search)(WT_CURSOR *cursor);

	/*!
	 * Return the record matching the key if it exists, otherwise the
	 * smallest record larger than the key or the largest record smaller
	 * than the key (in other words, a logically adjacent key); the key
	 * must first be set.
	 *
	 * @snippet ex_all.c Search for an exact or adjacent match
	 *
	 * @snippet ex_all.c Forward scan greater than or equal
	 *
	 * @snippet ex_all.c Backward scan less than
	 *
	 * @param cursor the cursor handle
	 * @param exactp the status of the search: 0 if an exact match is
	 * found, < 0 if a smaller key is returned, > 0 if a larger key is
	 * returned
	 * @errors
	 */
	int __F(search_near)(WT_CURSOR *cursor, int *exactp);
	/*! @} */

	/*! @name Data modification
	 * @{
	 */
	/*! Insert a record, and optionally overwrite an existing record.
	 * If the cursor was not configured with "overwrite", both the key and
	 * value must be set and the record must not already exist; the
	 * key/value pair will be inserted.
	 *
	 * If the cursor was configured with "overwrite", both the key and value
	 * must be set; if the record already exists, the key's value will be
	 * updated, otherwise, the key/value pair will be inserted.
	 *
	 * In table or file with a record number key, if the cursor was
	 * configured with "append", the value must be set; a new record will
	 * be appended and its number returned as the key value.
	 *
	 * @snippet ex_all.c Insert a new record
	 *
	 * @snippet ex_all.c Insert a new record or overwrite an existing record
	 *
	 * @snippet ex_all.c Insert a new record and assign a record number
	 *
	 * @param cursor the cursor handle
	 * @errors
	 */
	int __F(insert)(WT_CURSOR *cursor);

	/*! Update a record.  Both key and value must be set, the key must
	 * exist, and the value of the key's record will be updated.
	 *
	 * @snippet ex_all.c Update an existing record
	 *
	 * @param cursor the cursor handle
	 * @errors
	 */
	int __F(update)(WT_CURSOR *cursor);

	/*! Remove a record.  The key must be set, and the key's record will be
	 * removed.
	 *
	 * @snippet ex_all.c Remove a record
	 *
	 * @param cursor the cursor handle
	 * @errors
	 */
	int __F(remove)(WT_CURSOR *cursor);
	/*! @} */

	/*! Close the cursor.
	 *
	 * This releases the resources associated with the cursor handle.
	 * Cursors are closed implicitly by ending the enclosing transaction or
	 * closing the session in which they were opened.
	 *
	 * @snippet ex_all.c Close the cursor
	 *
	 * @param cursor the cursor handle
	 * @configstart{cursor.close, see dist/api_data.py}
	 * @config{clear, for statistics cursors\, reset statistics counters.
	 * The value must be a boolean flag.,\c false}
	 * @configend
	 * @errors
	 */
	int __F(close)(WT_CURSOR *cursor, const char *config);

	/*
	 * Protected fields, only to be used by cursor implementations.
	 */

#if !defined(SWIG) && !defined(DOXYGEN)
	/*
	 * !!!
	 * Explicit representations of structures from queue.h.
	 * TAILQ_ENTRY(wt_cursor) q;
	 */
	struct {
		WT_CURSOR *tqe_next;
		WT_CURSOR **tqe_prev;
	} q;                            /* Linked list of WT_CURSORs. */

	uint64_t recno;
	uint8_t raw_recno_buf[20];	/* Holds a recno in raw mode. */
	WT_BUF key, value;
	int saved_err;			/* Saved error in set_{key,value}. */

#define	WT_CURSTD_APPEND	0x0001
#define	WT_CURSTD_DUMP_HEX	0x0002
#define	WT_CURSTD_DUMP_PRINT	0x0004
#define	WT_CURSTD_KEY_SET	0x0008
#define	WT_CURSTD_OVERWRITE	0x0010
#define	WT_CURSTD_PUBLIC	0x0020
#define	WT_CURSTD_RAW		0x0040
#define	WT_CURSTD_TABLE		0x0080
#define	WT_CURSTD_VALUE_SET	0x0100
	uint32_t flags;
#endif
};

/*!
 * All data operations are performed in the context of a WT_SESSION.  This
 * encapsulates the thread and transactional context of the operation.
 *
 * <b>Thread safety:</b> A WT_SESSION handle cannot be shared between threads:
 * it may only be used within a single thread.  Each thread accessing a
 * database should open a separate WT_SESSION handle.
 */
struct wt_session {
	/*! The connection for this session. */
	WT_CONNECTION *connection;

	/*! Close the session handle.
	 *
	 * This will release the resources associated with the session handle,
	 * including rolling any active transactions and closing any cursors
	 * that remain open in the session.
	 *
	 * @dontinclude ex_all.c
	 * @skipline session->close
	 *
	 * @param session the session handle
	 * @configempty{session.close, see dist/api_data.py}
	 * @errors
	 */
	int __F(close)(WT_SESSION *session, const char *config);

	/*! @name Cursor handles
	 * @{
	 */

	/*! Open a cursor.
	 *
	 * Open a new cursor on the specified data source.  Cursor handles
	 * should be discarded by calling WT_CURSOR::close.
	 *
	 * Cursors are opened in the context of the current transaction.  The
	 * cursor must be closed before the transaction can end.  If
	 * WT_SESSION::commit_transaction or WT_SESSION::rollback_transaction
	 * are called with cursors open in the transaction, the cursor handles
	 * will be closed implicitly and must not be accessed again.
	 *
	 * An existing cursor can be duplicated by passing it as the \c to_dup
	 * parameter, otherwise the \c to_dup parameter should be NULL.
	 *
	 * Cursors are commonly opened on ordinary tables.  However, cursors
	 * can be opened on any data source, regardless of whether it is
	 * ultimately stored in a table.  Some cursor types may have limited
	 * functionality (for example, be read-only, or not support
	 * transactional updates).
	 *
	 * The following are common builtin cursor types:
	 * <table>
	 *   @hrow{URI, Type}
	 *   @row{<tt>table:[\<tablename\>]</tt>, ordinary table cursor
	 *   		(key=table key\, value=table value)}
	 *   @row{<tt>index:\<tablename\>.\<indexname\></tt>, index cursor
	 *   		(key=index key\, value=table value)}
	 *   @row{<tt>statistics:[file</tt><tt>:\<filename\>]</tt>,
	 *   		database or table statistics
	 *   		(key=(string)description\,
	 *		    value=(string)value\, (uint64_t)value)}
	 * </table>
	 *
	 * See @ref cursor_types for more information.
	 *
	 * @snippet ex_all.c Open a cursor
	 *
	 * @param session the session handle
	 * @param uri the data source on which the cursor operates
	 * @param to_dup a cursor to duplicate
	 * @param session the session handle
	 * @configstart{session.open_cursor, see dist/api_data.py}
	 * @config{append, only supported by cursors with record number keys:
	 * append the value as a new record\, creating a new record number key.
	 * The value must be a boolean flag.,\c false}
	 * @config{bulk, configure the cursor for bulk loads. The value must be
	 * a boolean flag.,\c false}
	 * @config{dump, configure the cursor for dump format inputs and
	 * outputs: "hex" selects a simple hexadecimal format\, "print" selects
	 * a format where only non-printing characters are hexadecimal encoded.
	 * The value must be a string\, chosen from the following options: \c
	 * "hex"\, \c "print".,empty}
	 * @config{isolation, the isolation level for this cursor. Ignored for
	 * transactional cursors. The value must be a string\, chosen from the
	 * following options: \c "snapshot"\, \c "read-committed"\, \c
	 * "read-uncommitted".,\c read-committed}
	 * @config{overwrite, if an existing key is inserted\, overwrite the
	 * existing value. The value must be a boolean flag.,\c false}
	 * @config{raw, ignore the encodings for the key and value\, manage data
	 * as if the formats were \c "u". The value must be a boolean flag.,\c
	 * false}
	 * @config{statistics, configure the cursor for statistics. The value
	 * must be a boolean flag.,\c false}
	 * @configend
	 * @param cursorp a pointer to the newly opened cursor
	 * @errors
	 */
	int __F(open_cursor)(WT_SESSION *session,
	    const char *uri, WT_CURSOR *to_dup,
	    const char *config, WT_CURSOR **cursorp);
	/*! @} */

	/*! @name Table operations
	 * @{
	 */
	/*! Create a table, column group or index.
	 *
	 * @snippet ex_all.c Create a table
	 *
	 * @param session the session handle
	 * @param name the URI of the object to create, such as \c "table:stock"
	 * @configstart{session.create, see dist/api_data.py}
	 * @config{allocation_size, configure the file unit allocation size\, in
	 * bytes; the size must a power-of-two. The value must be an integer
	 * between 512B and 128MB.,\c 512B}
	 * @config{block_compressor, configure a compressor for file blocks.
	 * Permitted values are empty (off) or \c "<name>".  See @ref
	 * compressors for more details. The value must be a string.,empty}
	 * @config{colgroups, comma-separated list of names of column groups.
	 * Each column group is stored separately\, keyed by the primary key of
	 * the table.  If no column groups are specified\, all columns are
	 * stored together in a single file.  All value columns in the table
	 * must appear in at least one column group.  Each column group must be
	 * created with a separate call to WT_SESSION::create. The value must be
	 * a string.,empty}
	 * @config{collator,             configure custom collation for keys.
	 * Value must be a collator                 created with
	 * WT_CONNECTION::add_collator. The value must be a string.,empty}
	 * @config{columns, list of the column names.  Comma-separated list of
	 * the form <code>(column[\,...])</code>.  For tables\, the number of
	 * entries must match the total number of values in \c key_format and \c
	 * value_format.  For colgroups and indices\, all column names must
	 * appear in the list of columns for the table. The value must be a list
	 * of strings.,empty}
	 * @config{exclusive, fail if the object exists.  When false (the
	 * default)\, if the object exists\, check that its settings match the
	 * specified configuration. The value must be a boolean flag.,\c false}
	 * @config{filename, override the default filename derived from the
	 * object name. The value must be a string.,empty}
	 * @config{huffman_key, configure Huffman encoding for keys.  Permitted
	 * values are empty (off)\, \c "english" or \c "<filename>".  See @ref
	 * huffman for more details. The value must be a string.,empty}
	 * @config{huffman_value, configure Huffman encoding for values.
	 * Permitted values are empty (off)\, \c "english" or \c "<filename>".
	 * See @ref huffman for more details. The value must be a string.,empty}
	 * @config{internal_key_truncate, configure the Btree for truncation of
	 * internal keys\, discarding unnecessary trailing bytes on internal
	 * keys. The value must be a boolean flag.,\c true}
	 * @config{internal_node_max, configure the maximum page size for
	 * internal nodes\, in bytes; the size must be a multiple of the
	 * allocation size. The value must be an integer between 512B and
	 * 512MB.,\c 2KB}
	 * @config{internal_overflow_size, configure the internal node overflow
	 * key size\, in bytes. The value must be an integer greater than or
	 * equal to 40B.,\c 64B}
	 * @config{key_format, the format of the data packed into key items.
	 * See @ref packing for details.  By default\, applications use the
	 * WT_ITEM struct to manipulate raw byte arrays.  Key items of type \c
	 * 'r' are record numbers and records will be stored using a column
	 * store. The value must be a format string.,\c u}
	 * @config{key_gap, configure the maximum gap between instantiated keys
	 * in a Btree leaf page\, constraining the number of keys processed to
	 * instantiate a random Btree leaf page key. The value must be an
	 * integer greater than or equal to 0.,\c 10}
	 * @config{leaf_node_max, configure the maximum page size for leaf
	 * nodes\, in bytes; the size must be a multiple of the allocation size.
	 * The value must be an integer between 512B and 512MB.,\c 1MB}
	 * @config{leaf_overflow_size, configure the leaf node overflow key
	 * size\, in bytes. The value must be an integer greater than or equal
	 * to 40B.,\c 470B}
	 * @config{prefix_compression, configure the Btree for prefix
	 * compression\, storing keys as a count of bytes matching the previous
	 * key plus a unique suffix. The value must be a boolean flag.,\c true}
	 * @config{split_pct, configure the Btree page split size as a
	 * percentage of the maximum Btree page size\, that is\, when a Btree
	 * page is split\, it will be split into smaller pages\, where each page
	 * is the specified percentage of the maximum Btree page size. The value
	 * must be an integer between 25 and 100.,\c 75}
	 * @config{type, configure the file type. The value must be a string\,
	 * chosen from the following options: \c "btree".,\c btree}
	 * @config{value_format, the format of the data packed into value items.
	 * See @ref packing for details.  By default\, applications use the
	 * WT_ITEM struct to manipulate raw byte arrays.  Value items of type \c
	 * 't' are bitfields\, and in column stores will be stored using a
	 * fixed-length store. The value must be a format string.,\c u}
	 * @configend
	 * @errors
	 */
	int __F(create)(WT_SESSION *session,
	    const char *name, const char *config);

	/*! Drop (delete) a table.
	 *
	 * @dontinclude ex_all.c
	 * @skipline ->drop
	 *
	 * @param session the session handle
	 * @param name the URI of the table to drop, such as \c "table:stock"
	 * @configstart{session.drop, see dist/api_data.py}
	 * @config{force, return success if the object does not exist. The value
	 * must be a boolean flag.,\c false}
	 * @configend
	 * @errors
	 */
	int __F(drop)(WT_SESSION *session,
	    const char *name, const char *config);

	/*! Rename a table. @notyet{session->rename}
	 *
	 * @dontinclude ex_all.c
	 * @skipline ->rename
	 *
	 * @param session the session handle
	 * @param oldname the current URI of the table, such as \c "table:old"
	 * @param newname the new name of the table, e.g., \c "table:new"
	 * @configempty{session.rename, see dist/api_data.py}
	 * @errors
	 */
	int __F(rename)(WT_SESSION *session,
	    const char *oldname, const char *newname, const char *config);

	/*! Salvage a table.
	 *
	 * Salvage rebuilds the file, or files of which a table is comprised,
	 * discarding any corrupted file blocks.
	 *
	 * Previously deleted records may re-appear, and inserted records may
	 * disappear, when salvage is done, so salvage should not be run
	 * unless it is known to be necessary.  Normally, salvage should be
	 * called after a file or table has been corrupted, as reported by the
	 * WT_SESSION::verify method.
	 *
	 * Files are rebuilt in place, the salvage method overwrites the
	 * existing files.
	 *
	 * @dontinclude ex_all.c
	 * @skipline ->salvage
	 *
	 * @param session the session handle
	 * @param name the URI of the file or table to salvage
	 * @configstart{session.salvage, see dist/api_data.py}
	 * @config{force, force salvage even of files that do not appear to be
	 * WiredTiger files. The value must be a boolean flag.,\c false}
	 * @configend
	 * @errors
	 */
	int __F(salvage)(WT_SESSION *session,
	    const char *name, const char *config);

	/*! Sync a table.
	 *
	 * Flush dirty pages from a table to stable storage.  Note that not
	 * all pages are necessarily flushed (pages pinned in memory, or in
	 * use by other threads of control may not be written until all open
	 * session handles for the table are closed).
	 *
	 * @dontinclude ex_all.c
	 * @skipline ->sync
	 *
	 * @param session the session handle
	 * @param name the URI of the table to sync
	 * @configempty{session.sync, see dist/api_data.py}
	 * @errors
	 */
	int __F(sync)(WT_SESSION *session,
	    const char *name, const char *config);

	/*! Truncate a table. @notyet{session->truncate}
	 *
	 * @dontinclude ex_all.c
	 * @skipline ->truncate
	 *
	 * @param session the session handle
	 * @param name the URI of the table to truncate
	 * @param start optional cursor marking the start of the truncate
	 * operation.  If <code>NULL</code>, the truncate starts from the
	 * beginning of the table
	 * @param end optional cursor marking the end of the truncate
	 * operation.  If <code>NULL</code>, the truncate continues to the end
	 * of the table
	 * @param name the name of the table
	 * @configempty{session.truncate, see dist/api_data.py}
	 * @errors
	 */
	int __F(truncate)(WT_SESSION *session,
	    const char *name,
	    WT_CURSOR *start, WT_CURSOR *end, const char *config);

	/*! Verify a table.
	 *
	 * Verify reports if a file, or the files of which a table is
	 * comprised, have been corrupted.  The WT_SESSION::salvage method
	 * can be used to repair a corrupted file,
	 *
	 * @dontinclude ex_all.c
	 * @skipline ->verify
	 *
	 * @param session the session handle
	 * @param name the URI of the file or table to verify
	 * @configempty{session.verify, see dist/api_data.py}
	 * @errors
	 */
	int __F(verify)(WT_SESSION *session,
	    const char *name, const char *config);
	/*! @} */

	/*! @name Transactions
	 * @{
	 */
	/*! Start a transaction in this session. @notyet{transactions}
	 *
	 * All cursors opened in this session that support transactional
	 * semantics will operate in the context of the transaction.  The
	 * transaction remains active until ended with
	 * WT_SESSION::commit_transaction or WT_SESSION::rollback_transaction.
	 *
	 * Ignored if a transaction is in progress.
	 *
	 * @todo describe nested transactions / savepoints
	 *
	 * @dontinclude ex_all.c
	 * @skipline ->begin_transaction
	 *
	 * @param session the session handle
	 * @configstart{session.begin_transaction, see dist/api_data.py}
	 * @config{isolation, the isolation level for this transaction. The
	 * value must be a string\, chosen from the following options: \c
	 * "serializable"\, \c "snapshot"\, \c "read-committed"\, \c
	 * "read-uncommitted".,\c read-committed}
	 * @config{name, name of the transaction for tracing and debugging. The
	 * value must be a string.,empty}
	 * @config{priority, priority of the transaction for resolving
	 * conflicts. Transactions with higher values are less likely to abort.
	 * The value must be an integer between -100 and 100.,\c 0}
	 * @config{sync, how to sync log records when the transaction commits.
	 * The value must be a string\, chosen from the following options: \c
	 * "full"\, \c "flush"\, \c "write"\, \c "none".,\c full}
	 * @configend
	 * @errors
	 */
	int __F(begin_transaction)(WT_SESSION *session, const char *config);

	/*! Commit the current transaction. @notyet{transactions}
	 *
	 * Any cursors opened during the transaction will be closed before
	 * the commit is processed.
	 *
	 * Ignored if no transaction is in progress.
	 *
	 * @dontinclude ex_all.c
	 * @skipline ->commit_transaction
	 *
	 * @param session the session handle
	 * @configempty{session.commit_transaction, see dist/api_data.py}
	 * @errors
	 */
	int __F(commit_transaction)(WT_SESSION *session, const char *config);

	/*! Roll back the current transaction. @notyet{transactions}
	 *
	 * Any cursors opened during the transaction will be closed before
	 * the rollback is processed.
	 *
	 * Ignored if no transaction is in progress.
	 *
	 * @dontinclude ex_all.c
	 * @skipline ->rollback_transaction
	 *
	 * @param session the session handle
	 * @configempty{session.rollback_transaction, see dist/api_data.py}
	 * @errors
	 */
	int __F(rollback_transaction)(WT_SESSION *session, const char *config);

	/*! Flush the cache and/or the log and optionally archive log files.
	 * @notyet{checkpoint}
	 *
	 * @dontinclude ex_all.c
	 * @skipline ->checkpoint
	 *
	 * @param session the session handle
	 * @configstart{session.checkpoint, see dist/api_data.py}
	 * @config{archive, remove log files no longer required for
	 * transactional durability. The value must be a boolean flag.,\c false}
	 * @config{flush_cache, flush the cache. The value must be a boolean
	 * flag.,\c true}
	 * @config{flush_log, flush the log to disk. The value must be a boolean
	 * flag.,\c true}
	 * @config{force, write a new checkpoint even if nothing has changed
	 * since the last one. The value must be a boolean flag.,\c false}
	 * @config{log_size, only proceed if more than the specified number of
	 * bytes of log records have been written since the last checkpoint. The
	 * value must be an integer greater than or equal to 0.,\c 0}
	 * @config{timeout, only proceed if more than the specified number of
	 * milliseconds have elapsed since the last checkpoint. The value must
	 * be an integer greater than or equal to 0.,\c 0}
	 * @configend
	 * @errors
	 */
	int __F(checkpoint)(WT_SESSION *session, const char *config);

	/*! @} */
	/*! @name Debugging
	 * @{
	 */

	/*! Dump a physical file in debugging mode.
	 *
	 * The specified file is displayed in a non-portable debugging mode to
	 * the application's standard output.
	 *
	 * @dontinclude ex_all.c
	 * @skipline ->dumpfile
	 *
	 * @param session the session handle
	 * @param name the URI of the table to verify
	 * @configempty{session.dumpfile, see dist/api_data.py}
	 * @errors
	 */
	int __F(dumpfile)(WT_SESSION *session,
	    const char *name, const char *config);

	/*! Send a string to the message handler for debugging.
	 *
	 * @dontinclude ex_all.c
	 * @skipline ->msg_printf
	 *
	 * @param session the session handle
	 * @param fmt a printf-like format specification
	 * @errors
	 */
	int __F(msg_printf)(WT_SESSION *session, const char *fmt, ...);

	/*! @} */
};

/*!
 * A connection to a WiredTiger database.  The connection may be opened within
 * the same address space as the caller or accessed over a socket connection.
 *
 * Most applications will open a single connection to a database for each
 * process.  The first process to open a connection to a database will access
 * the database in its own address space.  Subsequent connections (if allowed)
 * will communicate with the first process over a socket connection to perform
 * their operations.
 */
struct wt_connection {
	/*! Load an extension.
	 *
	 * @dontinclude ex_all.c
	 * @skipline ->load_extension
	 *
	 * @param connection the connection handle
	 * @param path the filename of the extension module
	 * @configstart{connection.load_extension, see dist/api_data.py}
	 * @config{entry, the entry point of the extension. The value must be a
	 * string.,\c wiredtiger_extension_init}
	 * @config{prefix, a prefix for all names registered by this extension
	 * (e.g.\, to make namespaces distinct or during upgrades. The value
	 * must be a string.,empty}
	 * @configend
	 * @errors
	 */
	int __F(load_extension)(WT_CONNECTION *connection,
	    const char *path, const char *config);

	/*! Add a new type of cursor. @notyet{custom cursors}
	 *
	 * @dontinclude ex_all.c
	 *
	 * First the application must implement the WT_CURSOR_TYPE interface
	 * as follows:
	 *
	 * @snippet ex_all.c Implement WT_CURSOR_TYPE
	 *
	 * Then the implementation is registered with WiredTiger as follows:
	 *
	 * @snippet ex_all.c Register a new cursor type
	 *
	 * @param connection the connection handle
	 * @param prefix the prefix for location strings passed to
	 * WT_SESSION::open_cursor
	 * @param ctype the application-supplied code to manage cursors of
	 * this type
	 * @configempty{connection.add_cursor_type, see dist/api_data.py}
	 * @errors
	 */
	int __F(add_cursor_type)(WT_CONNECTION *connection,
	    const char *prefix, WT_CURSOR_TYPE *ctype, const char *config);

	/*! Add a custom collation function. @notyet{custom collation}
	 *
	 * First the application has to implement the WT_COLLATOR interface
	 * as follows:
	 *
	 * @snippet ex_all.c Implement WT_COLLATOR
	 *
	 * Then the implementation is registered with WiredTiger as follows:
	 *
	 * @snippet ex_all.c Register a new collator
	 *
	 * @param connection the connection handle
	 * @param name the name of the collation to be used in calls to
	 * 	WT_SESSION::create
	 * @param collator the application-supplied collation handler
	 * @configempty{connection.add_collator, see dist/api_data.py}
	 * @errors
	 */
	int __F(add_collator)(WT_CONNECTION *connection,
	    const char *name, WT_COLLATOR *collator, const char *config);

	/*! Add a compression function.
	 *
	 * First the application has to implement the WT_COMPRESSOR interface
	 * as follows:
	 *
	 * @snippet ex_all.c Implement WT_COMPRESSOR
	 *
	 * Then the implementation is registered with WiredTiger as follows:
	 *
	 * @snippet ex_all.c Register a new compressor
	 *
	 * @param connection the connection handle
	 * @param name the name of the compression function to be used in calls
	 *	to WT_SESSION::create
	 * @param compressor the application-supplied compression handler
	 * @configempty{connection.add_compressor, see dist/api_data.py}
	 * @errors
	 */
	int __F(add_compressor)(WT_CONNECTION *connection,
	    const char *name, WT_COMPRESSOR *compressor, const char *config);

	/*! Add a custom extractor for index keys or column groups.
	 * @notyet{custom extractors}
	 *
	 * First the application has to implement the WT_EXTRACTOR interface
	 * as follows:
	 *
	 * @snippet ex_all.c Implement WT_EXTRACTOR
	 *
	 * Then the implementation is registered with WiredTiger as follows:
	 *
	 * @snippet ex_all.c Register a new extractor
	 *
	 * @param connection the connection handle
	 * @param name the name of the extractor to be used in calls to
	 * 	WT_SESSION::create
	 * @param extractor the application-supplied extractor
	 * @configempty{connection.add_extractor, see dist/api_data.py}
	 * @errors
	 */
	int __F(add_extractor)(WT_CONNECTION *connection, const char *name,
	    WT_EXTRACTOR *extractor, const char *config);

	/*! Close a connection.
	 *
	 * Any open sessions will be closed.
	 *
	 * @dontinclude ex_all.c
	 * @skipline conn->close
	 *
	 * @param connection the connection handle
	 * @configempty{connection.close, see dist/api_data.py}
	 * @errors
	 */
	int __F(close)(WT_CONNECTION *connection, const char *config);

	/*! The home directory of the connection.
	 *
	 * @dontinclude ex_all.c
	 * @skipline ->get_home
	 *
	 * @param connection the connection handle
	 * @returns a pointer to a string naming the home directory
	 */
	const char *__F(get_home)(WT_CONNECTION *connection);

	/*! Did opening this handle create the database?
	 *
	 * @snippet ex_all.c is_new
	 *
	 * @param connection the connection handle
	 * @returns false (zero) if the connection existed before the call to
	 *    ::wiredtiger_open, true (non-zero) if it was created by opening
	 *    this handle.
	 */
	int __F(is_new)(WT_CONNECTION *connection);

	/*! Open a session.
	 *
	 * @snippet ex_all.c Open a session
	 *
	 * @param connection the connection handle
	 * @param errhandler An error handler.  If <code>NULL</code>, the
	 * connection's error handler is used
	 * @configempty{connection.open_session, see dist/api_data.py}
	 * @param sessionp the new session handle
	 * @errors
	 */
	int __F(open_session)(WT_CONNECTION *connection,
	    WT_EVENT_HANDLER *errhandler, const char *config,
	    WT_SESSION **sessionp);
};

/*! Open a connection to a database.
 *
 * @snippet ex_all.c Open a connection
 *
 * @param home The path to the database home directory.  See @ref home
 * for more information.
 * @param errhandler An error handler.  If <code>NULL</code>, a builtin error
 * handler is installed that writes error messages to stderr
 * @configstart{wiredtiger_open, see dist/api_data.py}
 * @config{cache_size, maximum heap memory to allocate for the cache. The value
 * must be an integer between 1MB and 10TB.,\c 20MB}
 * @config{create, create the database if it does not exist. The value must be a
 * boolean flag.,\c false}
 * @config{error_prefix, Prefix string for error messages. The value must be a
 * string.,empty}
 * @config{exclusive, fail if the database already exists. The value must be a
 * boolean flag.,\c false}
 * @config{extensions, list of extensions to load.  Optional values override the
 * name of the default entry function \c wiredtiger_init. The value must be a
 * list of strings.,empty}
 * @config{hazard_max, number of simultaneous hazard references per session
 * handle. The value must be an integer greater than or equal to 15.,\c 30}
 * @config{home_environment, use the WIREDTIGER_HOME environment variable for
 * naming unless the process is running with special privileges. See @ref home
 * for details. The value must be a boolean flag.,\c false}
 * @config{home_environment_priv, use the WIREDTIGER_HOME environment variable
 * for naming regardless of whether or not the process is running with special
 * privileges.  See @ref home for details. The value must be a boolean flag.,\c
 * false}
 * @config{logging, enable logging. The value must be a boolean flag.,\c false}
 * @config{multiprocess, permit sharing between processes (will automatically
 * start an RPC server for primary processes and use RPC for secondary
 * processes). The value must be a boolean flag.,\c false}
 * @config{multithread, permit sharing between threads of control (will
 * automatically serialize as necessary to allow multiple threads of control
 * simultaneous access to the database). The value must be a boolean flag.,\c
 * false}
 * @config{session_max, maximum expected number of sessions (including server
 * threads). The value must be an integer greater than or equal to 1.,\c 50}
 * @config{transactional, support transactional semantics. The value must be a
 * boolean flag.,\c false}
 * @config{verbose, enable messages for various events.  Options are given as a
 * list\, such as <code>"verbose=[evictserver\,read]"</code>. The value must be
 * a list\, with values chosen from the following options: \c "allocate"\, \c
 * "evictserver"\, \c "fileops"\, \c "hazard"\, \c "mutex"\, \c "read"\, \c
 * "readserver"\, \c "reconcile"\, \c "salvage"\, \c "write".,empty}
 * @configend
 * Additionally, if a file named \c WiredTiger.config appears in the WiredTiger
 * home directory, it is read for configuration values (see @ref config_file
 * for details).  Configuration values specified in the \c config argument to
 * the ::wiredtiger_open function override configuration values specified in
 * the \c WiredTiger.config file.
 * @param connectionp A pointer to the newly opened connection handle
 * @errors
 */
int wiredtiger_open(const char *home,
    WT_EVENT_HANDLER *errhandler, const char *config,
    WT_CONNECTION **connectionp);

/*! Return information about an error as a string; wiredtiger_strerror is a
 * superset of the ISO C99/POSIX 1003.1-2001 function strerror.
 *
 * @dontinclude ex_all.c
 * @skipline wiredtiger_strerror
 *
 * @param err a return value from a WiredTiger, C library or POSIX function
 * @returns a string representation of the error
 */
const char *wiredtiger_strerror(int err);

/*!
 * The interface implemented by applications in order to handle error messages,
 * information messages and progress.  Entries set to NULL are ignored and will
 * continue to use the default handlers.
 */
struct wt_event_handler {
	/*!
	 * Callback to handle error messages; by default, error messages are
	 * written to the stderr stream.
	 */
	void (*handle_error)(WT_EVENT_HANDLER *handler,
	    int error, const char *errmsg);

	/*!
	 * Callback to handle informational messages; by default, informational
	 * messages are written to the stdout stream.
	 */
	int (*handle_message)(WT_EVENT_HANDLER *handler, const char *message);

	/*!
	 * Callback to handle progress messages; by default, progress messages
	 * are ignored.
	 */
	int (*handle_progress)(WT_EVENT_HANDLER *handler,
	    const char *operation, uint64_t progress);
};

/*! Pack a structure into a buffer.
 *
 * See @ref packing for a description of the permitted format strings.
 *
 * @section pack_examples Packing Examples
 *
 * For example, the string <code>"iSh"</code> will pack a 32-bit integer
 * followed by a NUL-terminated string, followed by a 16-bit integer.  The
 * default, big-endian encoding will be used, with no alignment.  This could
 * be used in C as follows:
 *
 * @snippet ex_all.c Pack fields into a buffer
 *
 * Then later, the values can be unpacked as follows:
 *
 * @snippet ex_all.c Unpack fields from a buffer
 *
 * @param buffer a pointer to a packed byte array
 * @param size the number of valid bytes in the buffer
 * @param format the data format, see ::wiredtiger_struct_pack
 * @errors
 */
int wiredtiger_struct_pack(void *buffer, size_t size, const char *format, ...);

/*! Calculate the size required to pack a structure.
 *
 * Note that for variable-sized fields including variable-sized strings and
 * integers, the calculated sized merely reflects the expected sizes specified
 * in the format string itself.
 *
 * @snippet ex_all.c Get the packed size
 *
 * @param format the data format, see ::wiredtiger_struct_pack
 * @returns the number of bytes needed for the matching call to
 * ::wiredtiger_struct_pack
 */
size_t wiredtiger_struct_size(const char *format, ...);

/*! Unpack a structure from a buffer.
 *
 * Reverse of ::wiredtiger_struct_pack: gets values out of a packed byte string.
 *
 * @snippet ex_all.c Unpack fields from a buffer
 *
 * @param buffer a pointer to a packed byte array
 * @param size the number of valid bytes in the buffer
 * @param format the data format, see ::wiredtiger_struct_pack
 * @errors
 */
int wiredtiger_struct_unpack(const void *buffer, size_t size,
    const char *format, ...);

/*! Get version information.
 *
 * @snippet ex_all.c Get the WiredTiger library version
 *
 * @param majorp a location where the major version number is returned
 * @param minorp a location where the minor version number is returned
 * @param patchp a location where the patch version number is returned
 * @returns a string representation of the version
 */
const char *wiredtiger_version(int *majorp, int *minorp, int *patchp);

/*******************************************
 * Error returns
 *******************************************/
/*
 * DO NOT EDIT: automatically built by dist/api_err.py.
 * Error return section: BEGIN
 */
/*! Conflict with concurrent operation. */
#define	WT_DEADLOCK	-31800
/*! Attempt to insert an existing key. */
#define	WT_DUPLICATE_KEY	-31801
/*! Non-specific WiredTiger error. */
#define	WT_ERROR	-31802
/*! Item not found. */
#define	WT_NOTFOUND	-31803
/*! @cond internal
 * Restart the operation (internal).
 */
#define	WT_RESTART	-31804
/*! @endcond */
/*
 * Error return section: END
 * DO NOT EDIT: automatically built by dist/api_err.py.
 */

/*! @} */

/*! @defgroup wt_ext WiredTiger Extension API
 * The functions and interfaces that applications use to customize and extend
 * the behavior of WiredTiger.
 *
 * @{
 */

/*!
 * The interface implemented by applications to provide custom ordering of
 * records.  Applications register their implementation with WiredTiger by
 * calling WT_CONNECTION::add_collator.
 */
struct wt_collator {
	/*! Callback to compare keys.
	 *
	 * @param[out] cmp set to -1 if <code>key1 < key2</code>,
	 * 	0 if <code>key1 == key2</code>,
	 * 	1 if <code>key1 > key2</code>.
	 * @returns zero for success, non-zero to indicate an error.
	 */
	int (*compare)(WT_COLLATOR *collator, WT_SESSION *session,
	    const WT_ITEM *key1, const WT_ITEM *key2, int *cmp);
};

/*!
 * The interface implemented by applications to provide custom compression.
 * Applications register their implementation with WiredTiger by calling
 * WT_CONNECTION::add_compressor.
 */
struct wt_compressor {
	/*! Callback to compress a chunk of data.
	 *
	 * On entry, the \c dest field will point to memory, with the size
	 * of the memory in \c dest->size.  After successful completion,
	 * the callback should return \c 0 and set \c dest->size to the
	 * number of bytes required for the compressed representation.
	 *
	 * If the \c dest buffer is not big enough to hold the compressed data,
	 * the callback should set \c compression_failed to a non-zero value
	 * and return 0.
	 *
	 * @param[in] source the data to compress \c data field points to
	 *	memory; \c size field set to the number of bytes
	 * @param[in] dest \c data field points to memory;
	 *	\c size field set to maximum permitted size of compressed data
	 * @param[out] dest \c size the actual size of the compressed data
	 * @param[out] compression_failed \c non-zero if compression did not
	 * decrease the size of the data (compression may not have completed)
	 * @returns zero for success, non-zero to indicate an error.
	 */
	int (*compress)(WT_COMPRESSOR *compressor, WT_SESSION *session,
	    const WT_ITEM *source, WT_ITEM *dest, int *compression_failed);

	/*! Callback to decompress a chunk of data.
	 *
	 * On entry, the \c dest field will point to memory, with the size of
	 * the memory in \c dest->size.  After successful completion, the
	 * callback should return \c 0 and set \c dest->size to the number of
	 * bytes required for the decompressed representation.
	 *
	 * If the \c dest buffer is not big enough to hold the decompressed
	 * data, the callback should return an error.
	 *
	 * @param[in] source the compressed data \c data field points to
	 *	memory; \c size field set to the number of bytes
	 * @param[in] dest \c data field points to memory;
	 *	\c size set to maximum permitted size of decompressed data
	 * @param[out] dest \c size the actual size of the decompressed data
	 * @returns zero for success, non-zero to indicate an error.
	 */
	int (*decompress)(WT_COMPRESSOR *compressor, WT_SESSION *session,
	    const WT_ITEM *source, WT_ITEM *dest);
};

/*!
 * Applications can extend WiredTiger by providing new implementation of the
 * WT_CURSOR class.  This is done by implementing the WT_CURSOR_TYPE
 * interface, then calling WT_CONNECTION::add_cursor_type.
 *
 * <b>Thread safety:</b> WiredTiger may invoke methods on the WT_CURSOR_TYPE
 * interface from multiple threads concurrently.  It is the responsibility of
 * the implementation to protect any shared data.
 */
struct wt_cursor_type {
	/*! Callback to determine how much space to allocate for a cursor.
	 *
	 * If the callback is NULL, no additional space is allocated in the
	 * WT_CURSOR implementation.
	 *
	 * @errors
	 */
	int (*cursor_size)(WT_CURSOR_TYPE *ctype,
	    const char *obj, size_t *sizep);

	/*! Callback to initialize a cursor. */
	int (*init_cursor)(WT_CURSOR_TYPE *ctype,
	    WT_SESSION *session, const char *obj, WT_CURSOR *old_cursor,
	    const char *config, WT_CURSOR *new_cursor);
};

/*!
 * The interface implemented by applications to provide custom extraction of
 * index keys or column group values.  Applications register implementations
 * with WiredTiger by calling WT_CONNECTION::add_extractor.
 */
struct wt_extractor {
	/*! Callback to extract a value for an index or column group.
	 *
	 * @errors
	 */
	int (*extract)(WT_EXTRACTOR *extractor, WT_SESSION *session,
	    const WT_ITEM *key, const WT_ITEM *value,
	    WT_ITEM *result);
};

/*! Entry point to an extension, implemented by loadable modules.
 *
 * @param session the session handle
 * @param api entry points for WiredTiger functions exported to extensions
 * @param config the config string passed to WT_CONNECTION::load_extension
 * @errors
 */
extern int wiredtiger_extension_init(WT_SESSION *session,
    WT_EXTENSION_API *api, const char *config);

/*! @} */

#undef __F

#if defined(__cplusplus)
}
#endif
#endif /* __WIREDTIGER_H_ */
