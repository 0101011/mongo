#! /bin/sh

# Run standard scripts.
t=__wt.$$
trap 'rm -f $t *.pyc __tmp __wt.*' 0 1 2 3 13 15

# We require python which may not be installed.
type xpython > /dev/null 2>&1 || {
	echo 's_all: python not found'
	return 1
}

run()
{
	printf "$2..."
	$1 > $t

	if `grep 'skipped' $t > /dev/null 2>&1`; then
		printf " " && cat $t
	elif `test -s $t`; then
		echo
		sed -e 's/^/	/' $t
	else
		echo ' OK'
	fi
	rm -f $t
	return 0
}

echo 'dist/s_all run started...'

reconf=0
while :
	do case "$1" in
	-A)	# Reconfigure the library build.
		reconf=1
		shift;;
	*)
		break;;
	esac
done

test "$reconf" -eq 0 || {
	(cd ../build_posix &&
	run "sh ./reconf" "Rebuilding GNU tools library support")
}

run "python api_err.py" "Building error return API"
run "python api_flags.py" "Building API flags"
run "python config.py" "Building configuration code"
run "python log.py" "Building logging layer"
run "python stat.py" "Building statistics support"
run "python serial.py" "Building serial function support"

run "sh ./s_typedef -b" "Building standard typedefs"
run "sh ./s_prototypes" "Building function prototypes"
run "sh ./s_readme" "Building README file"
run "sh ./s_tags" "Building tags files"

run "sh ./s_copyright" "Checking copyright notices"
run "sh ./s_define" "Checking for unused #defines"
run "sh ./s_funcs" "Checking for unused functions"
run "sh ./s_printf" "Checking for non-portable printf/scanf"
run "sh ./s_longlines" "Checking for long lines"
run "sh ./s_string" "Checking string spelling"
run "sh ./s_style" "Checking style"
run "sh ./s_typedef -c" "Checking for unused typedefs"
run "sh ./s_types" "Checking for old-style types"
run "sh ./s_symbols" "Checking external symbol names"
run "sh ./s_whitespace" "Checking whitespace"

run "sh ./s_docs" "Generating documentation"

echo 'dist/s_all run finished'

return 0
