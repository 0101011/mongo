/*! @page schema Schemas

The tables we have seen so far have all had simple key/value pairs for records.  We now explain how to deal with more complex data in WiredTiger.

@section schema_intro Tables, Rows and Columns

A table is a logical representation of data consisting of cells in rows and columns.  For example, a database might have this table.

<table>
<tr><th>EmpId</th><th>Lastname</th><th>Firstname</th><th>Salary</th></tr>
<tr><td>1</td><td>Smith</td><td>Joe</td><td>40000</td></tr>
<tr><td>2</td><td>Jones</td><td>Mary</td><td>50000</td></tr>
<tr><td>3</td><td>Johnson</td><td>Cathy</td><td>44000</td></tr>
</table>

This simple table includes an employee identifier, last name and first name, and a salary.

A row-oriented database would store all of the values in a row together, then the values in the next row, and so on:

<pre>
      1,Smith,Joe,40000;
      2,Jones,Mary,50000;
      3,Johnson,Cathy,44000;
</pre>

A column-oriented database stores all of the values of a column together, then the values of the next column, and so on:

<pre>
      1,2,3;
      Smith,Jones,Johnson;
      Joe,Mary,Cathy;
      40000,50000,44000;
</pre>

WiredTiger supports both storage formats, and can mix and match the storage of columns within a logical table.

Applications describe the format of their data by supplying a schema to WT_SESSION::create.  This specifies how the application's data can be split into fields and mapped onto rows and columns.

@section schema_types Column types

WiredTiger's uses format strings similar to those specified in the Python
struct module to describe the types of columns in a table:
  http://docs.python.org/library/struct

@par Format types:

<table>
@hrow{Format, C Type, Java type, Python type, Standard size}
@row{x, pad byte, N/A, N/A, 1}
@row{b, signed char, byte, integer, 1}
@row{B, unsigned char, byte, integer, 1}
@row{h, short, short, integer, 2}
@row{H, unsigned short, short, integer, 2}
@row{i, int, int, integer, 4}
@row{I, unsigned int, int, integer, 4}
@row{l, long, int, integer, 4}
@row{L, unsigned long, int, integer, 4}
@row{q, long long, long, integer, 8}
@row{Q, unsigned long long, long, integer, 8}
@row{r, uint64_t, long, integer, 8}
@row{s, char[], String, string, fixed length}
@row{S, char[], String, string, variable}
@row{t, unsigned char, byte, integer, fixed bit length}
@row{u, WT_DATAITEM, byte[], string, variable}
</table>

The <code>'r'</code> type is used for record number keys in column stores.

The <code>'S'</code> type is encoded as a C language string terminated by a
NUL character.

The <code>'t'</code> type is used for fixed-length bit field values.  If it is preceded by a size, that indicates the number of bits to store, between 1 and 8.  That number of low-order bits will be stored in the table.  The default is a size of 1 bit: that is, a boolean.  Note that the application should always use an <code>unsigned char</code> type (or equivalently, <code>uint8_t</code>) for calls to WT_CURSOR::set_value, and a pointer to the same for calls to WT_CURSOR::get_value.  If a bit field value is combined with other types in a packing format, it is equivalent to <code>'B'</code>, and a full byte is used to store it.

The <code>'u'</code> type is for raw byte arrays: if it appears at the end
of a format string (including in the default <code>"u"</code> format for
untyped tables), the size is not stored explicitly.  When <code>'u'</code>
appears within a format string, the size is stored as a 32-bit integer in
the same byte order as the rest of the format string, followed by the data.

@section schema_data_access Columns in key and values

@todo Describe how to use WT_CURSOR::get_key, WT_CURSOR::get_value, WT_CURSOR::set_key and WT_CURSOR::set_value to access columns.

@section schema_columns Describing Columns

@todo describe how to add columns to a schema

@section schema_column_groups Storing Groups of Columns Together

@todo define and describe column groups

@section schema_indices Adding an Index

@todo describe how to add indices to a schema

@section schema_mapping Column Storage

@todo describe how to store some columns separately

@section schema_examples Code Samples

The code below is taken from the complete example program @ex_ref{ex_schema.c}.

@dontinclude ex_schema.c
@skip C struct
@until POP_RECORD

@skip open_session
@until conn->close

The code below is taken from the complete example program @ex_ref{ex_call_center.c}.

@dontinclude ex_call_center.c
@skip home
@until CALL

@skip create
@until conn->close

@todo new section: schema_advanced Advanced Schemas
@todo non-relational data such as multiple index keys per row
@todo application-supplied extractors and collators may need to be registered before recovery can run.

 */
