/*-
 * See the file LICENSE for redistribution information.
 *
 * Copyright (c) 2008 WiredTiger Software.  All rights reserved.
 *
 * $Id$
 */

#if defined(__cplusplus)
extern "C" {
#endif

/*******************************************
 * WiredTiger public include file, and configuration control.
 *******************************************/
#include "wiredtiger.h"
#include "wiredtiger_config.h"

/*******************************************
 * WiredTiger system include files.
 *******************************************/
#include <sys/stat.h>
#include <sys/uio.h>

#include <ctype.h>
#include <errno.h>
#include <fcntl.h>
#include <limits.h>
#include <pthread.h>
#include <stdarg.h>
#include <stdlib.h>
#include <string.h>
#include <unistd.h>

/*******************************************
 * WiredTiger externally maintained include files.
 *******************************************/
#include "queue.h"
#include "bitstring.h"

/*******************************************
 * Internal forward declarations.
 *******************************************/
struct __wt_btree;		typedef struct __wt_btree WT_BTREE;
struct __wt_cache;		typedef struct __wt_cache WT_CACHE;
struct __wt_fh;			typedef struct __wt_fh WT_FH;
struct __wt_lsn;		typedef struct __wt_lsn WT_LSN;
struct __wt_page_entry;		typedef struct __wt_page_entry WT_PAGE_ENTRY;
struct __wt_stats;		typedef struct __wt_stats WT_STATS;

/*******************************************
 * WiredTiger internal include files.
 *******************************************/
#include "mutex.h"

#include "btree.h"
#include "cache.h"
#include "debug.h"
#include "fh.h"
#include "mem.h"
#include "misc.h"
#include "stat.h"

/*******************************************
 * Default values -- grouped together so it's obvious what to re-configure.
 *******************************************/
#define	WT_CACHE_DRAIN_CNT	(10)	/* Default pages to drain at a time */
#define	WT_CACHE_ENTRY_DEFAULT	(40)	/* Default cache allocation unit */
#define	WT_CACHE_SIZE_DEFAULT	(20)	/* Default cache size in MB */
#define	WT_HAZARD_SIZE_DEFAULT	(15)	/* Default number of hazard refs */
#define	WT_TOC_SIZE_DEFAULT	(50)	/* Default number of TOCs */

/*******************************************
 * WT_TOC support.
 *******************************************/
/*
 * Set/clear the WT_TOC's generation number; done in the API level, as well as
 * periodically by long-running operations.
 */
#define	WT_TOC_GEN_CLR(toc)						\
	(toc)->gen = UINT32_MAX
#define	WT_TOC_GEN_SET(toc)						\
	(toc)->gen = (toc)->env->ienv->api_gen

/*******************************************
 * Memory reference tracking information.
 *******************************************/
#define	WT_FLIST_MAX	50

/*
 * WT_FLIST --
 *	A structure to track memory references with API generations.
 */
struct __wt_flist {
	TAILQ_ENTRY(__wt_flist) q;		/* Linked list */

	u_int32_t gen;				/* API generation */

	struct {				/* Memory references */
		void *p;
		u_int32_t len;
	} ref[WT_FLIST_MAX];
	u_int	  cnt;
};

#define	WT_FLIST_INSERT(toc, __p, __l) do {				\
	WT_FLIST *__fp = (toc)->flist;					\
	if (__fp == NULL || __fp->cnt == WT_FLIST_MAX)			\
		__wt_flist_insert(toc, __p, __l);			\
	else {								\
		__fp->ref[__fp->cnt].p = (__p);				\
		__fp->ref[__fp->cnt].len = (__l);			\
		++__fp->cnt;						\
	}								\
	__p = NULL;							\
} while (0)

/*******************************************
 * Cursor handle information that doesn't persist.
 *******************************************/
struct __idbc {
	DBC *dbc;			/* Public object */
};

/*******************************************
 * Database handle information that doesn't persist.
 *******************************************/
struct __idb {
	DB *db;				/* Public object */
	TAILQ_ENTRY(__idb) q;		/* Linked list of databases */

	char	 *name;			/* Database name */
	mode_t	  mode;			/* Database file create mode */

	u_int32_t file_id;		/* In-memory file ID */
	WT_FH	 *fh;			/* Backing file handle */

	u_int32_t root_addr;		/* Root page addr */
	u_int32_t root_len;		/* Root page len */

	/*
	 * The root page is pinned into memory when the database is opened
	 * and/or created; if the root_page isn't set, there's usually not
	 * much to do.
	 */
#define	WT_UNOPENED_DATABASE(idb)	((idb)->root_page == NULL ? 1 : 0)
	WT_PAGE  *root_page;		/* Root page */

	u_int32_t free_addr;		/* Free page addr */
	u_int32_t free_len;		/* Free page len */

	void *huffman_key;		/* Key huffman encoding */
	void *huffman_data;		/* Data huffman encoding */

	WT_STATS *stats;		/* Database handle statistics */
	WT_STATS *dstats;		/* Database file statistics */

	u_int32_t flags;
};

/*******************************************
 * Environment handle information that doesn't persist.
 *******************************************/
struct __ienv {
	WT_MTX *mtx;			/* Global mutex */

	pthread_t cache_drain_tid;	/* Cache drian thread ID */
	pthread_t cache_io_tid;		/* Cache I/O thread ID */
	pthread_t workq_tid;		/* workQ thread ID */

	TAILQ_HEAD(
	    __wt_db_qh, __idb) dbqh;	/* Locked: database list */

	TAILQ_HEAD(
	    __wt_fh_qh, __wt_fh) fhqh;	/* Locked: file list */
	u_int next_file_id;		/* Locked: file ID counter */

	u_int32_t volatile api_gen;	/* API generation number */

	/*
	 * WiredTiger allocates space for 50 simultaneous threads of control by
	 * default.   The Env.toc_max_set method tunes this if the application
	 * needs more.   Growing the number of threads dynamically is possible,
	 * but tricky since the workQ is walking the array without locking it.
	 *
	 * There's an array of WT_TOC pointers that reference the allocated
	 * array; we do it that way because we want an easy way for the workQ
	 * code to avoid walking the entire array when only a few threads are
	 * running.
	 */
	WT_TOC	**toc;			/* TOC reference */
	u_int32_t toc_cnt;		/* TOC count */
	void	 *toc_array;		/* TOC array */

	/*
	 * WiredTiger allocates space for 15 hazard references in each thread of
	 * control, by default.  The Env.hazard_max_set method tunes this if an
	 * application needs more, but that shouldn't happen, there's no code
	 * path that requires more than 15 pages at a time (and if we find one,
	 * the right change is to increase the default).  The method is there
	 * just in case an application starts failing in the field.
	 *
	 * The hazard array is separate from the WT_TOC array because we want to
	 * be able to easily copy and search it when draining the cache.
	 */
	WT_PAGE **hazard;		/* Hazard references array */

	/*
	 * WiredTiger has a thread that frees memory lazily once it's known that
	 * no more references exist.  The workQ thread owns the queue of memory
	 * references used by that thread.
	 */
	TAILQ_HEAD(			/* Free list queue */
	    __wt_flisth, __wt_flist) flistq;

	WT_CACHE  *cache;		/* Page cache */
	u_int32_t  page_gen;		/* Page cache LRU generation number */

	WT_STATS *stats;		/* Environment handle statistics */
	WT_STATS *method_stats;		/* Environment method statistics */

#ifdef HAVE_DIAGNOSTIC
	WT_MTRACK *mtrack;		/* Memory tracking information */
#endif

	char *sep;			/* Display separator line */
	char err_buf[32];		/* Last-ditch error buffer */

	u_int32_t flags;
};

#include "serial.h"
#include "extern.h"

#if defined(__cplusplus)
}
#endif
