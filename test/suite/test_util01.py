#!/usr/bin/env python
#
# See the file LICENSE for redistribution information.
#
# Copyright (c) 2008-2011 WiredTiger, Inc.
#	All rights reserved.
#
# test_util01.py
# 	Utilities, like wt [ dump | load ].
#

import unittest
import wiredtiger
import wttest
import subprocess
import os
import string

class test_util01(wttest.WiredTigerTestCase):
    """
    Test wt
    """

    tablename = 'test_util01.wt'
    nentries = 1000

    # python has a filecmp.cmp function, but different versions
    # of python approach file comparison differently.  To make
    # sure we really get byte for byte comparison, we define it here.

    def compare_files(self, filename1, filename2):
        bufsize = 4096
        if os.path.getsize(filename1) != os.path.getsize(filename2):
            print filename1 + ' size = ' + str(os.path.getsize(filename1))
            print filename2 + ' size = ' + str(os.path.getsize(filename2))
            return False
        with open(filename1, "rb") as fp1:
            with open(filename2, "rb") as fp2:
                while True:
                    b1 = fp1.read(bufsize)
                    b2 = fp2.read(bufsize)
                    if b1 != b2:
                        return False
                    # files are identical size
                    if not b1:
                        return True

    def get_string(self, i, len):
        """
        Return a pseudo-random, but predictable string that uses
        all characters.
        """
        ret = ''
        for j in range(0, len / 3):
            k = i + j
            # we ensure that there are no internal nulls, that would
            # truncate the string when we're using the 'S' encoding
            ret += chr(k%255 + 1) + chr((k*3)%255 + 1) + chr((k*7)%255 + 1)
        return ret

    def get_key(self, i):
        return ("%0.6d" % i) + ':' + self.get_string(i, 20)

    def get_value(self, i):
        return self.get_string(i, 1000)

    def dumpstr(self, s):
        """
        Return a key or value string formatted just as 'wt dump' would.
        Most printable characters (except tab, newline,...) are printed
        as is, otherwise, backslash hex is used.
        """
        result = ''
        for c in s:
            if c == '\\':
                result += '\\\\'
            elif c == ' ' or (c in string.printable and not c in string.whitespace):
                result += c
            else:
                result += '\\' + "%0.2x" % ord(c)
        return result + '\\00\n'

    def test_dump_process(self):
        params = 'key_format=S,value_format=S'
        self.session.create('table:' + self.tablename, params)
        cursor = self.session.open_cursor('table:' + self.tablename, None, None)
        value = ""
        ver = wiredtiger.wiredtiger_version()
        verstring = str(ver[1]) + '.' + str(ver[2]) + '.' + str(ver[3])
        with open("expect.out", "w") as expectout:
            # Note: this output is sensitive to the precise output format
            # generated by dump.  If this is likely to change, we should
            # make this test more accommodating.
            expectout.write('WiredTiger Dump (WiredTiger Version ' + verstring + ')\n')
            expectout.write('Format=print\n')
            expectout.write('Header\n')
            expectout.write('table:' + self.tablename + '\n')
            expectout.write('colgroups=,columns=,' + params + '\n')
            expectout.write('Data\n')
            for i in range(0, self.nentries):
                key = self.get_key(i)
                value = self.get_value(i)
                cursor.set_key(key)
                cursor.set_value(value)
                cursor.insert()
                expectout.write(self.dumpstr(key))
                expectout.write(self.dumpstr(value))
            cursor.close()

        # we close the connection to guarantee everything is
        # flushed, and that we can open it from another process
        self.conn.close(None)
        self.conn = None

        self.pr('calling dump')
        with open("dump.out", "w") as dumpout:
            proc = subprocess.Popen(["../../wt", "dump", self.tablename],
                                    stdout=dumpout)
            proc.wait()
        self.assertTrue(self.compare_files("expect.out", "dump.out"))

if __name__ == '__main__':
    wttest.run()
